name: CI/CD with Minikube, Docker Hub, and GitHub Actions

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
  DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
  DOCKER_IMAGE_NAME: my-node-app
  DOCKER_REPO: ${{ secrets.DOCKER_USERNAME }}/my-node-app 
  CONTAINER_NAME: minikube-ci-env

jobs:
  build-test-deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 15 # Give ample time for Minikube to start

    steps:
    - name: üì¶ Checkout Repository
      uses: actions/checkout@v4

    # ----------------------------------------------------
    # --- 1. Build and Test Application ---
    # ----------------------------------------------------
    - name: üõ†Ô∏è Set up Docker BuildX
      uses: docker/setup-buildx-action@v3

    - name: üèóÔ∏è Build Application Image (Local)
      # Build the application image using the local context
      run: docker build -t ${{ env.DOCKER_IMAGE_NAME }}:latest -f app/Dockerfile .

    - name: üß™ Run Application Tests
      run: |
        docker run --rm ${{ env.DOCKER_IMAGE_NAME }}:latest npm test

    # ----------------------------------------------------
    # --- 2. Minikube Deployment (Test Environment) ---
    # ----------------------------------------------------
    - name: üê≥ Build Minikube-in-DinD Image
      # Build the Minikube DinD image using the new Dockerfile with checks
      run: docker build -t minikube-dind:latest -f minikube-dind/Dockerfile . 

    - name: üöÄ Start Minikube-in-DinD Service and Wait for Kubernetes
      id: start_minikube
      run: |
        TIMEOUT=600 # 10 minutes wait
        ELAPSED=0
        
        # Start the DinD container in privileged mode, running the start-minikube.sh entrypoint
        docker run -d --privileged --name ${{ env.CONTAINER_NAME }} minikube-dind:latest

        echo "Waiting for Minikube Kubernetes API (max ${TIMEOUT} seconds)..."
        
        while [ $ELAPSED -lt $TIMEOUT ]; do
          if ! docker ps -q -f name=${{ env.CONTAINER_NAME }}; then
            echo "::error::Minikube DinD container exited unexpectedly during startup! Check minikube-dind/start-minikube.sh for errors."
            docker logs ${{ env.CONTAINER_NAME }}
            exit 1
          fi
          
          # Health Check: Check if kubectl can see the nodes
          if docker exec ${{ env.CONTAINER_NAME }} kubectl get nodes >/dev/null 2>&1; then
            echo "Minikube Kubernetes API is ready and configured! üéâ"
            break
          fi
          
          sleep 5
          ELAPSED=$((ELAPSED + 5))
        done
        
        if [ $ELAPSED -ge $TIMEOUT ]; then
          echo "::error::Minikube failed to start within the timeout period. üò≠"
          
          echo "::group::Minikube Status and Logs for Failure Diagnosis"
          docker exec ${{ env.CONTAINER_NAME }} minikube status || true
          docker logs ${{ env.CONTAINER_NAME }}
          echo "::endgroup::"
          exit 1
        fi

    - name: üì§ Load Application Image into Minikube's Docker Daemon
      # Transfers the app image from the host runner into the DinD environment
      run: |
        docker save ${{ env.DOCKER_IMAGE_NAME }}:latest | docker exec -i ${{ env.CONTAINER_NAME }} docker load

    - name: üö¢ Deploy Application to Minikube and Verify Rollout
      run: |
        # Creates k8s deployment YAML
        cat <<EOF > deployment.yaml
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: my-node-app-deployment
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: my-node-app
          template:
            metadata:
              labels:
                app: my-node-app
            spec:
              containers:
              - name: my-node-app
                image: ${{ env.DOCKER_IMAGE_NAME }}:latest
                imagePullPolicy: Never # Critical: Forces use of the locally loaded image
                ports:
                - containerPort: 3000
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: my-node-app-service
        spec:
          selector:
            app: my-node-app
          ports:
            - protocol: TCP
              port: 80
              targetPort: 3000
          type: NodePort
        EOF
        
        # Copies and applies the YAML inside the running Minikube container
        docker cp deployment.yaml ${{ env.CONTAINER_NAME }}:/tmp/deployment.yaml
        docker exec ${{ env.CONTAINER_NAME }} kubectl apply -f /tmp/deployment.yaml
        
        echo "Waiting for deployment rollout to finish..."
        docker exec ${{ env.CONTAINER_NAME }} kubectl rollout status deployment/my-node-app-deployment --timeout=5m

    # ----------------------------------------------------
    # --- 3. Push to Docker Hub (Final Artifact) ---
    # ----------------------------------------------------
    - name: üîë Log in to Docker Hub
      # Skips if credentials are not provided
      if: success() && env.DOCKER_USERNAME != ''
      uses: docker/login-action@v3
      with:
        username: ${{ env.DOCKER_USERNAME }}
        password: ${{ env.DOCKER_PASSWORD }}

    - name: üè∑Ô∏è Tag and Push Application Image to Docker Hub
      # This step uses the DOCKER_REPO variable
      if: success() && env.DOCKER_USERNAME != ''
      run: |
        docker tag ${{ env.DOCKER_IMAGE_NAME }}:latest ${{ env.DOCKER_REPO }}:latest
        docker push ${{ env.DOCKER_REPO }}:latest
        echo "Image successfully pushed to Docker Hub as ${{ env.DOCKER_REPO }}:latest"

    - name: üßπ Clean up Minikube-in-DinD container
      if: always()
      run: docker stop ${{ env.CONTAINER_NAME }} && docker rm ${{ env.CONTAINER_NAME }}
